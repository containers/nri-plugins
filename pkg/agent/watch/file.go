// Copyright The NRI Plugins Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package watch

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"sync"

	"github.com/fsnotify/fsnotify"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/watch"
)

// UnmarshalFn unmarshals YAML data into an object.
type UnmarshalFn func([]byte, string) (runtime.Object, error)

// FileWatch monitors a file for changes. It implements the apimachinery
// watch.Interface and generates events similar to the ones generated by
// an apimachinery watch for custom resources or configmaps.
type FileWatch struct {
	dir       string
	file      string
	unmarshal UnmarshalFn
	fsw       *fsnotify.Watcher
	resultC   chan Event
	stopLock  sync.Mutex
	stopC     chan struct{}
	doneC     chan struct{}
}

// File creates a watch for monitoring the given file.
func File(file string, unmarshal UnmarshalFn) (Interface, error) {
	abs, err := filepath.Abs(file)
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute path to %s: %w", file, err)
	}

	fsw, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, fmt.Errorf("failed to create fsnotify watch: %w", err)
	}

	w := &FileWatch{
		dir:       path.Dir(abs),
		file:      path.Base(abs),
		unmarshal: unmarshal,
		fsw:       fsw,
		resultC:   make(chan Event, watch.DefaultChanSize),
		stopC:     make(chan struct{}),
		doneC:     make(chan struct{}),
	}

	if err = fsw.Add(w.dir); err != nil {
		return nil, fmt.Errorf("failed to add %s to watch: %w", w.dir, err)
	}

	if err = w.run(); err != nil {
		return nil, err
	}

	return w, nil
}

// Stop stops the watch.
func (w *FileWatch) Stop() {
	w.stopLock.Lock()
	defer w.stopLock.Unlock()

	if w.stopC != nil {
		close(w.stopC)
		_ = <-w.doneC
		w.stopC = nil
	}
}

// ResultChan returns the watch channel for receiving events.
func (w *FileWatch) ResultChan() <-chan Event {
	return w.resultC
}

func (w *FileWatch) run() error {
	obj, err := w.readAndUnmarshal()
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		return err
	}

	w.sendEvent(Added, obj)

	go func() {
		for {
			select {
			case <-w.stopC:
				w.fsw.Close()
				close(w.resultC)
				close(w.doneC)
				return

			case e, ok := <-w.fsw.Events:
				if !ok {
					w.sendEvent(
						Error,
						&metav1.Status{
							Status:  metav1.StatusFailure,
							Message: "failed to receive event from fsnotify channel",
						},
					)
					close(w.resultC)
					close(w.doneC)
					return
				}

				if path.Base(e.Name) != w.file {
					continue
				}

				log.Debug("got %v event for %s", e.Op, e.Name)

				switch {
				case (e.Op & fsnotify.Create) != 0:
					obj, err := w.readAndUnmarshal()
					if err != nil {
						log.Warnf("%v", err)
						continue
					}

					w.sendEvent(Added, obj)

				case (e.Op & fsnotify.Write) != 0:
					obj, err := w.readAndUnmarshal()
					if err != nil {
						log.Warnf("%v", err)
						continue
					}

					w.sendEvent(Modified, obj)

				case (e.Op & (fsnotify.Remove | fsnotify.Rename)) != 0:
					w.sendEvent(Deleted, nil)
				}
			}
		}
	}()

	return nil
}

func (w *FileWatch) sendEvent(t EventType, obj runtime.Object) {
	select {
	case w.resultC <- Event{Type: t, Object: obj}:
	default:
		log.Warn("failed to deliver file watch event (%v)", t)
	}
}

func (w *FileWatch) readAndUnmarshal() (runtime.Object, error) {
	file := path.Join(w.dir, w.file)

	data, err := os.ReadFile(file)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", file, err)
	}

	obj, err := w.unmarshal(data, file)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal data from %s: %w", file, err)
	}

	return obj, nil
}
