<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Topology-Aware Policy &mdash; NRI Plugins v0.9.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=c20ff342"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Balloons Policy" href="balloons.html" />
    <link rel="prev" title="Policies" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NRI Plugins
          </a>
              <div class="version">
                v0.9.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Resource Policy Plugins</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../setup.html">Setup and Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../configuration.html">Dynamic Configuration</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Policies</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Topology-Aware Policy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#features">Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuring-the-policy">Configuring the Policy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#policy-cpu-allocation-preferences">Policy CPU Allocation Preferences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#container-cpu-allocation-preference-annotations">Container CPU Allocation Preference Annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disabling-cpu-or-memory-pinning-of-a-container">Disabling CPU or Memory Pinning of a Container</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cold-start">Cold Start</a></li>
<li class="toctree-l4"><a class="reference internal" href="#container-memory-requests-and-limits">Container memory requests and limits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reserved-pool-namespaces">Reserved pool namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reserved-cpu-annotations">Reserved CPU annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controlling-topology-hints-via-annotations">Controlling Topology Hints Via Annotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#container-affinity-and-anti-affinity">Container Affinity and Anti-Affinity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metrics-and-debugging">Metrics and Debugging</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="balloons.html">Balloons Policy</a></li>
<li class="toctree-l3"><a class="reference internal" href="template.html">Template Policy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../developers-guide/index.html">Developer’s Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../memory/index.html">Memory plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deployment/index.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/containers/nri-plugins">Project GitHub repository</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NRI Plugins</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Resource Policy Plugins</a></li>
          <li class="breadcrumb-item"><a href="index.html">Policies</a></li>
      <li class="breadcrumb-item active">Topology-Aware Policy</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/docs/resource-policy/policy/topology-aware.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="topology-aware-policy">
<h1>Topology-Aware Policy<a class="headerlink" href="#topology-aware-policy" title="Link to this heading"></a></h1>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading"></a></h2>
<p>On server-grade hardware the CPU cores, I/O devices and other peripherals
form a rather complex network together with the memory controllers, the
I/O bus hierarchy and the CPU interconnect. When a combination of these
resources are allocated to a single workload, the performance of that
workload can vary greatly, depending on how efficiently data is transferred
between them or, in other words, on how well the resources are aligned.</p>
<p>There are a number of inherent architectural hardware properties that,
unless properly taken into account, can cause resource misalignment and
workload performance degradation. There are a multitude of CPU cores
available to run workloads. There are a multitude of memory controllers
these workloads can use to store and retrieve data from main memory. There
are a multitude of I/O devices attached to a number of I/O buses the same
workloads can access. The CPU cores can be divided into a number of groups,
with each group having different access latency and bandwidth to each
memory controller and I/O device.</p>
<p>If a workload is not assigned to run with a properly aligned set of CPU,
memory and devices, it will not be able to achieve optimal performance.
Given the idiosyncrasies of hardware, allocating a properly aligned set
of resources for optimal workload performance requires identifying and
understanding the multiple dimensions of access latency locality present
in hardware or, in other words, hardware topology awareness.</p>
</section>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">topology-aware</span></code> policy automatically builds a tree of pools based on the
detected hardware topology. Each pool has a set of CPUs and memory zones
assigned as their resources. Resource allocation for workloads happens by
first picking the pool which is considered to fit the best the resource
requirements of the workload and then assigning CPU and memory from this pool.</p>
<p>The pool nodes at various depths from bottom to top represent the NUMA nodes,
dies, sockets, and finally the whole of the system at the root node. Leaf NUMA
nodes are assigned the memory behind their controllers / zones and CPU cores
with the smallest distance / access penalty to this memory. If the machine
has multiple types of memory separately visible to both the kernel and user
space, for instance both DRAM and
<a class="reference external" href="https://www.intel.com/content/www/us/en/products/memory-storage/optane-dc-persistent-memory.html">PMEM</a>,
each zone of special type of memory is assigned to the closest NUMA node pool.</p>
<p>Each non-leaf pool node in the tree is assigned the union of the resources of
its children. So in practice, dies nodes end up containing all the CPU cores
and the memory zones in the corresponding die, sockets nodes end up containing
the CPU cores and memory zones in the corresponding socket’s dies, and the root
ends up containing all CPU cores and memory zones in all sockets.</p>
<p>With this setup, each pool in the tree has a topologically aligned set of CPU
and memory resources. The amount of available resources gradually increases in
the tree from bottom to top, while the strictness of alignment is gradually
relaxed. In other words, as one moves from bottom to top in the tree, it is
getting gradually easier to fit in a workload, but the price paid for this is
a gradually increasing maximum potential cost or penalty for memory access and
data transfer between CPU cores.</p>
<p>Another property of this setup is that the resource sets of sibling pools at
the same depth in the tree are disjoint while the resource sets of descendant
pools along the same path in the tree partially overlap, with the intersection
decreasing as the the distance between pools increases. This makes it easy to
isolate workloads from each other. As long as workloads are assigned to pools
which has no other common ancestor than the root, the resources of these
workloads should be as well isolated from each other as possible on the given
hardware.</p>
<p>With such an arrangement, this policy should handle topology-aware alignment
of resources without any special or extra configuration. When allocating
resources, the policy</p>
<ul class="simple">
<li><p>filters out all pools with insufficient free capacity</p></li>
<li><p>runs a scoring algorithm for the remaining ones</p></li>
<li><p>picks the one with the best score</p></li>
<li><p>assigns resources to the workload from there</p></li>
</ul>
<p>Although the details of the scoring algorithm are subject to change as the
implementation evolves, its basic principles are roughly</p>
<ul class="simple">
<li><p>prefer pools lower in the tree, IOW stricter alignment and lower latency</p></li>
<li><p>prefer idle pools over busy ones, IOW more remaining free capacity and
fewer workloads</p></li>
<li><p>prefer pools with better overall device alignment</p></li>
</ul>
</section>
<section id="features">
<h2>Features<a class="headerlink" href="#features" title="Link to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">topology-aware</span></code> policy has the following features:</p>
<ul class="simple">
<li><p>topologically aligned allocation of CPU and memory</p>
<ul>
<li><p>assign CPU and memory to workloads with tightest available alignment</p></li>
</ul>
</li>
<li><p>aligned allocation of devices</p>
<ul>
<li><p>pick pool for workload based on locality of devices already assigned</p></li>
</ul>
</li>
<li><p>shared allocation of CPU cores</p>
<ul>
<li><p>assign workload to shared subset of pool CPUs</p></li>
</ul>
</li>
<li><p>exclusive allocation of CPU cores</p>
<ul>
<li><p>dynamically slice off CPU cores from shared subset and assign to workload</p></li>
</ul>
</li>
<li><p>mixed allocation of CPU cores</p>
<ul>
<li><p>assign both exclusive and shared CPU cores to workload</p></li>
</ul>
</li>
<li><p>discovering and using kernel-isolated CPU cores (<a class="reference external" href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html#cpu-lists">‘isolcpus’</a>)</p>
<ul>
<li><p>use kernel-isolated CPU cores for exclusively assigned CPU cores</p></li>
</ul>
</li>
<li><p>exposing assigned resources to workloads</p></li>
<li><p>notifying workloads about changes in resource assignment</p></li>
<li><p>dynamic relaxation of memory alignment to prevent OOM</p>
<ul>
<li><p>dynamically widen workload memory set to avoid pool/workload OOM</p></li>
</ul>
</li>
<li><p>multi-tier memory allocation</p>
<ul>
<li><p>assign workloads to memory zones of their preferred type</p></li>
<li><p>the policy knows about three kinds of memory:</p>
<ul>
<li><p>DRAM is regular system main memory</p></li>
<li><p>PMEM is large-capacity memory, such as
<a class="reference external" href="https://www.intel.com/content/www/us/en/products/memory-storage/optane-dc-persistent-memory.html">Intel® Optane™ memory</a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/High_Bandwidth_Memory">HBM</a> is high
speed memory, typically found on some special-purpose computing systems</p></li>
</ul>
</li>
</ul>
</li>
<li><p>cold start</p>
<ul>
<li><p>pin workload exclusively to PMEM for an initial warm-up period</p></li>
</ul>
</li>
</ul>
</section>
<section id="configuring-the-policy">
<h2>Configuring the Policy<a class="headerlink" href="#configuring-the-policy" title="Link to this heading"></a></h2>
<p>The policy has a number of configuration options which affect its default
behavior. These options can be supplied as part of the effective
<a class="reference internal" href="../configuration.html"><span class="std std-doc">dynamic configuration</span></a> custom resource.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pinCPU</span></code></p>
<ul>
<li><p>whether to pin workloads to assigned pool CPU sets</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinMemory</span></code></p>
<ul>
<li><p>whether to pin workloads to assigned pool memory zones</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">preferIsolatedCPUs</span></code></p>
<ul>
<li><p>whether isolated CPUs are preferred by default for workloads that are
eligible for exclusive CPU allocation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">preferSharedCPUs</span></code></p>
<ul>
<li><p>whether shared allocation is preferred by default for workloads that
would be otherwise eligible for exclusive CPU allocation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">reservedPoolNamespaces</span></code></p>
<ul>
<li><p>list of extra namespaces (or glob patterns) that will be allocated to
reserved CPUs</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">colocatePods</span></code></p>
<ul>
<li><p>whether try to allocate containers in a pod to the same or close by
topology pools</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">colocateNamespaces</span></code></p>
<ul>
<li><p>whether try to allocate containers in a namespace to the same or close by
topology pools</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultCPUPriority</span></code></p>
<ul>
<li><p>is the default CPU prioritization, used when a container has not been
annotated with any other CPU preferences. The possible values are: <code class="docutils literal notranslate"><span class="pre">high</span></code>,
<code class="docutils literal notranslate"><span class="pre">normal</span></code>, <code class="docutils literal notranslate"><span class="pre">low</span></code>, and <code class="docutils literal notranslate"><span class="pre">none</span></code>. Currently this option only affects exclusive
CPU allocations. For a more detailed discussion of CPU prioritization see
the <a class="reference internal" href="../developers-guide/cpu-allocator.html"><span class="std std-doc">cpu allocator</span></a> documentation.</p></li>
</ul>
</li>
</ul>
<p>Additionally, the following sub-configuration is available for instrumentation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">instrumentation</span></code>: configures runtime instrumentation.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">httpEndpoint</span></code>: the address the HTTP server listens on. Example:
<code class="docutils literal notranslate"><span class="pre">:8891</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prometheusExport</span></code>: if set to True, metrics about system and topology zone
resource assignment are readable through <code class="docutils literal notranslate"><span class="pre">/metrics</span></code> from the configured
<code class="docutils literal notranslate"><span class="pre">httpEndpoint</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reportPeriod</span></code>: <code class="docutils literal notranslate"><span class="pre">/metrics</span></code> aggregation interval for polled metrics.</p></li>
</ul>
</li>
</ul>
</section>
<section id="policy-cpu-allocation-preferences">
<h2>Policy CPU Allocation Preferences<a class="headerlink" href="#policy-cpu-allocation-preferences" title="Link to this heading"></a></h2>
<p>There are a number of workload properties this policy actively checks to decide
if the workload could potentially benefit from extra resource allocation
optimizations. Unless configured differently, containers fulfilling certain
corresponding criteria are considered eligible for these optimizations. This
will be reflected in the assigned resources whenever that is possible at the
time the container’s creation / resource allocation request hits the policy.</p>
<p>The set of these extra optimizations consist of</p>
<ul class="simple">
<li><p>assignment of <code class="docutils literal notranslate"><span class="pre">kube-reserved</span></code> CPUs</p></li>
<li><p>assignment of exclusively allocated CPU cores</p></li>
<li><p>usage of kernel-isolated CPU cores (for exclusive allocation)</p></li>
</ul>
<p>The policy uses a combination of the QoS class and the resource requirements of
the container to decide if any of these extra allocation preferences should be
applied. Containers are divided into five groups, with each group having a
slightly different set of criteria for eligibility.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kube-system</span></code> group</p>
<ul>
<li><p>all containers in the <code class="docutils literal notranslate"><span class="pre">kube-system</span></code> namespace</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">low-priority</span></code> group</p>
<ul>
<li><p>containers in the <code class="docutils literal notranslate"><span class="pre">BestEffort</span></code> or <code class="docutils literal notranslate"><span class="pre">Burstable</span></code> QoS class</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub-core</span></code> group</p>
<ul>
<li><p>Guaranteed QoS class containers with <code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">request</span> <span class="pre">&lt;</span> <span class="pre">1</span> <span class="pre">CPU</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mixed</span></code> group</p>
<ul>
<li><p>Guaranteed QoS class containers with <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">CPU</span> <span class="pre">request</span> <span class="pre">&lt;</span> <span class="pre">2</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">multi-core</span></code> group</p>
<ul>
<li><p>Guaranteed QoS class containers with <code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">request</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code></p></li>
</ul>
</li>
</ul>
<p>The eligibility rules for extra optimization are slightly different among these
groups.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kube-system</span></code></p>
<ul>
<li><p>not eligible for extra optimizations</p></li>
<li><p>eligible to run on <code class="docutils literal notranslate"><span class="pre">kube-reserved</span></code> CPU cores</p></li>
<li><p>always run on shared CPU cores</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">low-priority</span></code></p>
<ul>
<li><p>not eligible for extra optimizations</p></li>
<li><p>always run on shared CPU cores</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sub-core</span></code></p>
<ul>
<li><p>not eligible for extra optimizations</p></li>
<li><p>always run on shared CPU cores</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mixed</span></code></p>
<ul>
<li><p>by default eligible for exclusive and isolated allocation</p></li>
<li><p>not eligible for either if <code class="docutils literal notranslate"><span class="pre">preferSharedCPUs</span></code> is set to true</p></li>
<li><p>not eligible for either if annotated to opt out from exclusive allocation</p></li>
<li><p>not eligible for isolated allocation if annotated to opt out</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">multi-core</span></code></p>
<ul>
<li><p>CPU request fractional (<code class="docutils literal notranslate"><span class="pre">(CPU</span> <span class="pre">request</span> <span class="pre">%</span> <span class="pre">1000</span> <span class="pre">milli-CPU)</span> <span class="pre">!=</span> <span class="pre">0</span></code>):</p>
<ul>
<li><p>by default not eligible for extra optimizations</p></li>
<li><p>eligible for exclusive and isolated allocation if annotated to opt in</p></li>
</ul>
</li>
<li><p>CPU request not fractional:</p>
<ul>
<li><p>by default eligible for exclusive allocation</p></li>
<li><p>by default not eligible for isolated allocation</p></li>
<li><p>not eligible for exclusive allocation if annotated to opt out</p></li>
<li><p>eligible for isolated allocation if annotated to opt in</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Eligibility for kube-reserved CPU core allocation should always be possible to
honor. If this is not the case, it is probably due to an incorrect configuration
which underdeclares <code class="docutils literal notranslate"><span class="pre">ReservedResources</span></code>. In that case, ordinary shared CPU cores
will be used instead of kube-reserved ones.</p>
<p>Eligibility for exclusive CPU allocation should always be possible to honor.
Eligibility for isolated core allocation is only honored if there are enough
isolated cores available to fulfill the exclusive part of the container’s CPU
request with isolated cores alone. Otherwise ordinary CPUs will be allocated,
by slicing them off for exclusive usage from the shared subset of CPU cores in
the container’s assigned pool.</p>
<p>Containers in the kube-system group are pinned to share all kube-reserved CPU
cores. Containers in the low-priority or sub-core groups, and containers which
are only eligible for shared CPU core allocation in the mixed and multi-core
groups, are all pinned to run on the shared subset of CPU cores in the
container’s assigned pool. This shared subset can and usually does change
dynamically as exclusive CPU cores are allocated and released in the pool.</p>
</section>
<section id="container-cpu-allocation-preference-annotations">
<h2>Container CPU Allocation Preference Annotations<a class="headerlink" href="#container-cpu-allocation-preference-annotations" title="Link to this heading"></a></h2>
<p>Containers can be annotated to diverge from the default CPU allocation
preferences the policy would otherwise apply to them. These Pod annotations
can be given both with per pod and per container resolution. If for any
container both of these exist, the container-specific one takes precedence.</p>
<section id="shared-exclusive-and-isolated-cpu-preference-cpu-priorities">
<h3>Shared, Exclusive, and Isolated CPU Preference, CPU Priorities<a class="headerlink" href="#shared-exclusive-and-isolated-cpu-preference-cpu-priorities" title="Link to this heading"></a></h3>
<p>A container can opt in to or opt out from shared CPU allocation using the
following Pod annotation.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># opt in container C1 to shared CPU core allocation</span>
<span class="w">    </span><span class="nt">prefer-shared-cpus.resource-policy.nri.io/container.C1</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="w">    </span><span class="c1"># opt in the whole pod to shared CPU core allocation</span>
<span class="w">    </span><span class="nt">prefer-shared-cpus.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="w">    </span><span class="c1"># selectively opt out container C2 from shared CPU core allocation</span>
<span class="w">    </span><span class="nt">prefer-shared-cpus.resource-policy.nri.io/container.C2</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span>
<span class="w">    </span><span class="c1"># prefer low-prio CPUs for all others except the &#39;pump&#39; container</span>
<span class="w">    </span><span class="nt">prefer-cpu-priority.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">low</span>
<span class="w">    </span><span class="nt">prefer-cpu-priority.resource-policy.nri.io/container.pump</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">high</span>
</pre></div>
</div>
<p>Opting in to exclusive allocation happens by opting out from shared allocation,
and opting out from exclusive allocation happens by opting in to shared
allocation.</p>
<p>A container can opt in to or opt out from isolated exclusive CPU core
allocation using the following Pod annotation.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># opt in container C1 to isolated exclusive CPU core allocation</span>
<span class="w">    </span><span class="nt">prefer-isolated-cpus.resource-policy.nri.io/container.C1</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="w">    </span><span class="c1"># opt in the whole pod to isolated exclusive CPU core allocation</span>
<span class="w">    </span><span class="nt">prefer-isolated-cpus.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="w">    </span><span class="c1"># selectively opt out container C2 from isolated exclusive CPU core allocation</span>
<span class="w">    </span><span class="nt">prefer-isolated-cpus.resource-policy.nri.io/container.C2</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span>
</pre></div>
</div>
<p>These Pod annotations have no effect on containers which are not eligible for
exclusive allocation.</p>
</section>
<section id="selectively-disabling-hyperthreading">
<h3>Selectively Disabling Hyperthreading<a class="headerlink" href="#selectively-disabling-hyperthreading" title="Link to this heading"></a></h3>
<p>If a container opts to hide hyperthreads, it is allowed to use only
one hyperthread from every physical CPU core allocated to it. Note
that as a result the container may be allowed to run on only half of
the CPUs it has requested. In case of workloads that do not benefit
from hyperthreading this nevertheless results in better performance
compared to running on all hyperthreads of the same CPU cores. If
container’s CPU allocation is exclusive, no other container can run on
hidden hyperthreads either.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># allow the &quot;LLM&quot; container to use only single thread per physical CPU core</span>
<span class="w">    </span><span class="nt">hide-hyperthreads.resource-policy.nri.io/container.LLM</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
</pre></div>
</div>
</section>
<section id="implicit-hardware-topology-hints">
<h3>Implicit Hardware Topology Hints<a class="headerlink" href="#implicit-hardware-topology-hints" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">NRI</span> <span class="pre">Resource</span> <span class="pre">Policy</span></code> automatically generates HW <code class="docutils literal notranslate"><span class="pre">Topology</span> <span class="pre">Hints</span></code> for devices
assigned to a container, prior to handing the container off to the active policy
for resource allocation. The <code class="docutils literal notranslate"><span class="pre">topology-aware</span></code> policy is hint-aware and normally
takes topology hints into account when picking the best pool to allocate resources.
Hints indicate optimal <code class="docutils literal notranslate"><span class="pre">HW</span> <span class="pre">locality</span></code> for device access and they can alter
significantly which pool gets picked for a container.</p>
<p>Since device topology hints are implicitly generated, there are cases where one
would like the policy to disregard them altogether. For instance, when a local
volume is used by a container but not in any performance critical manner.</p>
<p>Containers can be annotated to opt out from and selectively opt in to hint-aware
pool selection using the following Pod annotations.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># only disregard hints for container C1</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/container.C1</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span>
<span class="w">    </span><span class="c1"># disregard hints for all containers by default</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span>
<span class="w">    </span><span class="c1"># but take hints into account for container C2</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/container.C2</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
</pre></div>
</div>
<p>Topology hint generation is globally enabled by default. Therefore, using the
Pod annotation as opt in only has an effect when the whole pod is annotated to
opt out from hint-aware pool selection.</p>
</section>
<section id="implicit-topological-co-location-for-pods-and-namespaces">
<h3>Implicit Topological Co-location for Pods and Namespaces<a class="headerlink" href="#implicit-topological-co-location-for-pods-and-namespaces" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">colocatePods</span></code> or <code class="docutils literal notranslate"><span class="pre">colocateNamespaces</span></code> configuration options control whether
the policy will try to co-locate, that is allocate topologically close, containers
within the same Pod or K8s namespace.</p>
<p>Both of these options are false by default. Setting them to true is a shorthand
for adding to each container an affinity of weight 10 for all other containers
in the same pod or namespace.</p>
<p>Containers with user-defined affinities are never extended with either of these
co-location affinities. However, such containers can still have affinity effects
on other containers that do get extended with co-location. Therefore mixing user-
defined affinities with implicit co-location requires both careful consideration
and a thorough understanding of affinity evaluation, or it should be avoided
altogether.</p>
</section>
</section>
<section id="disabling-cpu-or-memory-pinning-of-a-container">
<h2>Disabling CPU or Memory Pinning of a Container<a class="headerlink" href="#disabling-cpu-or-memory-pinning-of-a-container" title="Link to this heading"></a></h2>
<p>Some containers may need to run on all CPUs or access all memories
without restrictions. Annotate these pods and containers to prevent
the resource policy from touching their CPU or memory pinning.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">cpu.preserve.resource-policy.nri.io/container.CONTAINER_NAME</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="nt">cpu.preserve.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="nt">cpu.preserve.resource-policy.nri.io</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>

<span class="nt">memory.preserve.resource-policy.nri.io/container.CONTAINER_NAME</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="nt">memory.preserve.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="nt">memory.preserve.resource-policy.nri.io</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
</pre></div>
</div>
</section>
<section id="cold-start">
<h2>Cold Start<a class="headerlink" href="#cold-start" title="Link to this heading"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">topology-aware</span></code> policy supports “cold start” functionality. When cold start
is enabled and the workload is allocated to a topology node with both DRAM and
PMEM memory, the initial memory controller is only the PMEM controller. DRAM
controller is added to the workload only after the cold start timeout is
done. The effect of this is that allocated large unused memory areas of
memory don’t need to be migrated to PMEM, because it was allocated there to
begin with. Cold start is configured like this in the pod metadata:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">memory-type.resource-policy.nri.io/container.container1</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">dram,pmem</span>
<span class="w">    </span><span class="nt">cold-start.resource-policy.nri.io/container.container1</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">duration: 60s</span>
</pre></div>
</div>
<p>Again, alternatively you can use the following deprecated Pod annotation syntax
to achieve the same, but support for this syntax is subject to be dropped in a
future release:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/memory-type</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">container1: dram,pmem</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/cold-start</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">container1:</span>
<span class="w">        </span><span class="no">duration: 60s</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">container1</span></code> would be initially granted only PMEM
memory controller, but after 60 seconds the DRAM controller would be
added to the container memset.</p>
</section>
<section id="container-memory-requests-and-limits">
<h2>Container memory requests and limits<a class="headerlink" href="#container-memory-requests-and-limits" title="Link to this heading"></a></h2>
<p>Due to inaccuracies in how <code class="docutils literal notranslate"><span class="pre">nri-resource-policy</span></code> calculates memory requests for
pods in QoS class <code class="docutils literal notranslate"><span class="pre">Burstable</span></code>, you should either use <code class="docutils literal notranslate"><span class="pre">Limit</span></code> for setting
the amount of memory for containers in <code class="docutils literal notranslate"><span class="pre">Burstable</span></code> pods to provide <code class="docutils literal notranslate"><span class="pre">cri-resmgr</span></code>
with an exact copy of the resource requirements from the Pod Spec as an extra
Pod annotation.</p>
</section>
<section id="reserved-pool-namespaces">
<h2>Reserved pool namespaces<a class="headerlink" href="#reserved-pool-namespaces" title="Link to this heading"></a></h2>
<p>User is able to mark certain namespaces to have a reserved CPU allocation.
Containers belonging to such namespaces will only run on CPUs set aside
according to the global CPU reservation, as configured by the ReservedResources
configuration option in the policy section.
The <code class="docutils literal notranslate"><span class="pre">reservedPoolNamespaces</span></code> option is a list of namespace globs that will be
allocated to reserved CPU class.</p>
<p>For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nt">reservedPoolNamespaces</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;my-pool&quot;</span><span class="p p-Indicator">,</span><span class="s">&quot;reserved-*&quot;</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>In this setup, all the workloads in <code class="docutils literal notranslate"><span class="pre">my-pool</span></code> namespace and those namespaces
starting with <code class="docutils literal notranslate"><span class="pre">reserved-</span></code> string are allocated to reserved CPU class.
The workloads in <code class="docutils literal notranslate"><span class="pre">kube-system</span></code> are automatically assigned to reserved CPU
class so no need to mention <code class="docutils literal notranslate"><span class="pre">kube-system</span></code> in this list.</p>
</section>
<section id="reserved-cpu-annotations">
<h2>Reserved CPU annotations<a class="headerlink" href="#reserved-cpu-annotations" title="Link to this heading"></a></h2>
<p>User is able to mark certain pods and containers to have a reserved CPU
allocation by using annotations. Containers having a such annotation will only
run on CPUs set aside according to the global CPU reservation, as configured by
the ReservedResources configuration option in the policy section.</p>
<p>For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">prefer-reserved-cpus.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;true&quot;</span>
<span class="w">    </span><span class="nt">prefer-reserved-cpus.resource-policy.nri.io/container.special</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span>
</pre></div>
</div>
</section>
<section id="controlling-topology-hints-via-annotations">
<h2>Controlling Topology Hints Via Annotations<a class="headerlink" href="#controlling-topology-hints-via-annotations" title="Link to this heading"></a></h2>
<p>It is possible to control whether and what kind of topology hints are
generated using extra pod annotations. By default hints are generated
from mounts and devices injected into the container. If pod resource API
queries are enabled, query replies are also used for hint generation.</p>
<section id="enabling-or-disabling-selected-types-of-topology-hints">
<h3>Enabling Or Disabling Selected Types of Topology Hints<a class="headerlink" href="#enabling-or-disabling-selected-types-of-topology-hints" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">topologyhints.resource-policy.nri.io</span></code> annotation key can be used
to enable or disable topology hint generation for one or more containers
altogether, or selectively for mounts, devices, and pod resources types.
More than one type can be specified as a comma-separated list. Additionally,
the <code class="docutils literal notranslate"><span class="pre">all</span></code> and <code class="docutils literal notranslate"><span class="pre">none</span></code> types are recognized to mean all or none of these
types. If no hint type annotations are present, all types of hints are
enabled.</p>
<p>For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># disable topology hint generation for all containers by default</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">none</span>
<span class="w">    </span><span class="c1"># enable mount-based hints for the &#39;diskwriter&#39; container</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/container.diskwriter</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mounts</span>
<span class="w">    </span><span class="c1"># enable device-based hints for the &#39;videoencoder&#39; container</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/container.diskwriter</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">devices</span>
<span class="w">    </span><span class="c1"># enable pod resource-based hints for the &#39;dpdk&#39; container</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/container.dpdk</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">pod-resources</span>
<span class="w">    </span><span class="c1"># enable device and pod resource-based hints for &#39;networkpump&#39; container</span>
<span class="w">    </span><span class="nt">topologyhints.resource-policy.nri.io/container.networkpump</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">devices,pod-resources</span>
</pre></div>
</div>
<p>Note that for pod resource based hints, you also need to enable pod
resource API queries using the corresponding configuration option, like
this:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">config.nri/v1alpha1</span>
<span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">TopologyAwarePolicy</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">default</span>
<span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">agent</span><span class="p p-Indicator">:</span>
<span class="w">    </span><span class="nt">podResourceAPI</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
</pre></div>
</div>
</section>
<section id="controlling-topology-hints-by-path">
<h3>Controlling Topology Hints by Path<a class="headerlink" href="#controlling-topology-hints-by-path" title="Link to this heading"></a></h3>
<p>It is also possible to enable and disable topology hint generation based
on mount or device path, using <code class="docutils literal notranslate"><span class="pre">allow</span></code> and <code class="docutils literal notranslate"><span class="pre">deny</span></code> lists. When the policy
is generating topology hints, it consults these lists to decide whether
hints for a particular mount or device are enabled. The <code class="docutils literal notranslate"><span class="pre">deny</span></code> list is
consulted first, followed by the <code class="docutils literal notranslate"><span class="pre">allow</span></code> list. A common usage pattern is
to deny all paths, then allow only selected ones.</p>
<p>Two types of <code class="docutils literal notranslate"><span class="pre">allow</span></code> and <code class="docutils literal notranslate"><span class="pre">deny</span></code> lists are supported: <code class="docutils literal notranslate"><span class="pre">glob</span></code> and <code class="docutils literal notranslate"><span class="pre">prefix</span></code>.
A path matches a prefix list if it starts with any entry in the list. A
path matches a glob list, where entries include shell-style path globbing
with wildcards, it the full path matches any glob pattern in the list.</p>
<p>For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="c1"># Deny all hints by default.</span>
<span class="w">    </span><span class="nt">deny.topologyhints.resource-policy.nri.io/pod</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|+</span>
<span class="w">      </span><span class="no">type: prefix</span>
<span class="w">      </span><span class="no">paths:</span>
<span class="w">        </span><span class="no">- /</span>
<span class="w">    </span><span class="c1"># Allow hints from /sys/devices/pci*/*d7:00.0/*:d8:00.1 for container ctr1.</span>
<span class="w">    </span><span class="nt">allow.topologyhints.resource-policy.nri.io/container.ctr1</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|+</span>
<span class="w">      </span><span class="no">type: glob</span>
<span class="w">      </span><span class="no">paths:</span>
<span class="w">        </span><span class="no">- /sys/devices/pci*/*d7:00.0/*:d8:00.*</span>
<span class="w">    </span><span class="c1"># Allow hints for local NVME block devices.</span>
<span class="w">    </span><span class="c1"># I/O backing device for meaningful hint generation) for ctr2</span>
<span class="w">    </span><span class="nt">allow.topologyhints.resource-policy.nri.io/container.ctr2</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|+</span>
<span class="w">      </span><span class="no">type: prefix</span>
<span class="w">      </span><span class="no">paths:</span>
<span class="w">        </span><span class="no">- /dev/nvme</span>
</pre></div>
</div>
</section>
<section id="using-pod-resource-api-for-extra-topology-hints">
<h3>Using Pod Resource API for Extra Topology Hints<a class="headerlink" href="#using-pod-resource-api-for-extra-topology-hints" title="Link to this heading"></a></h3>
<p>If access to the <code class="docutils literal notranslate"><span class="pre">kubelet</span></code>’s <code class="docutils literal notranslate"><span class="pre">Pod</span> <span class="pre">Resource</span> <span class="pre">API</span></code> is enabled in the
<a class="reference internal" href="../developers-guide/architecture.html#node-agent"><span class="std std-ref">Node Agent’s</span></a> configuration,
and pod resource-based hints are not explicitly disabled by annotation, per-
container topology hints are automatically generated whenever a device with
locality to a NUMA node is advertised by the API. Annotated allow and deny
lists can be used to selectively disable or enable per-resource hints, using
<code class="docutils literal notranslate"><span class="pre">podresapi:$RESOURCE_NAME</span></code> as the path for the resource.</p>
</section>
</section>
<section id="container-affinity-and-anti-affinity">
<h2>Container Affinity and Anti-Affinity<a class="headerlink" href="#container-affinity-and-anti-affinity" title="Link to this heading"></a></h2>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h3>
<p>The topology-aware resource policy allow the user to give hints about how
particular containers should be <em>co-located</em> within a node. In particular these
hints express whether containers should be located <em>‘close’</em> to each other or
<em>‘far away’</em> from each other, in a hardware topology sense.</p>
<p>Since these hints are interpreted always by a particular <em>policy implementation</em>,
the exact definitions of ‘close’ and ‘far’ are also somewhat <em>policy-specific</em>.
However as a general rule of thumb containers running</p>
<ul class="simple">
<li><p>on CPUs within the <em>same NUMA nodes</em> are considered <em>‘close’</em> to each other,</p></li>
<li><p>on CPUs within <em>different NUMA nodes</em> in the <em>same socket</em> are <em>‘farther’</em>, and</p></li>
<li><p>on CPUs within <em>different sockets</em> are <em>‘far’</em> from each other</p></li>
</ul>
<p>These hints are expressed by <code class="docutils literal notranslate"><span class="pre">container</span> <span class="pre">affinity</span> <span class="pre">annotations</span></code> on the Pod.
There are two types of affinities:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">affinity</span></code> (or <code class="docutils literal notranslate"><span class="pre">positive</span> <span class="pre">affinity</span></code>): cause affected containers to <em>pull</em> each
other closer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anti-affinity</span></code> (or <code class="docutils literal notranslate"><span class="pre">negative</span> <span class="pre">affinity</span></code>): cause affected containers to <em>push</em>
each other further away</p></li>
</ul>
<p>Policies try to place a container</p>
<ul class="simple">
<li><p>close to those the container has affinity towards</p></li>
<li><p>far from those the container has anti-affinity towards.</p></li>
</ul>
</section>
<section id="affinity-annotation-syntax">
<h3>Affinity Annotation Syntax<a class="headerlink" href="#affinity-annotation-syntax" title="Link to this heading"></a></h3>
<p><em>Affinities</em> are defined as the <code class="docutils literal notranslate"><span class="pre">resource-policy.nri.io/affinity</span></code> annotation.
<em>Anti-affinities</em> are defined as the <code class="docutils literal notranslate"><span class="pre">resource-policy.nri.io/anti-affinity</span></code>
annotation. They are specified in the <code class="docutils literal notranslate"><span class="pre">metadata</span></code> section of the <code class="docutils literal notranslate"><span class="pre">Pod</span> <span class="pre">YAML</span></code>, under
<code class="docutils literal notranslate"><span class="pre">annotations</span></code> as a dictionary, with each dictionary key being the name of the
<em>container</em> within the Pod to which the annotation belongs to.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">container1:</span>
<span class="w">        </span><span class="no">- scope:</span>
<span class="w">            </span><span class="no">key: key-ref</span>
<span class="w">            </span><span class="no">operator: op</span>
<span class="w">            </span><span class="no">values:</span>
<span class="w">            </span><span class="no">- value1</span>
<span class="w">            </span><span class="no">...</span>
<span class="w">            </span><span class="no">- valueN</span>
<span class="w">          </span><span class="no">match:</span>
<span class="w">            </span><span class="no">key: key-ref</span>
<span class="w">            </span><span class="no">operator: op</span>
<span class="w">            </span><span class="no">values:</span>
<span class="w">            </span><span class="no">- value1</span>
<span class="w">            </span><span class="no">...</span>
<span class="w">            </span><span class="no">- valueN</span>
<span class="w">          </span><span class="no">weight: w</span>
</pre></div>
</div>
<p>An anti-affinity is defined similarly but using <code class="docutils literal notranslate"><span class="pre">resource-policy.nri.io/anti-affinity</span></code>
as the annotation key.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/anti-affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">container1:</span>
<span class="w">        </span><span class="no">- scope:</span>
<span class="w">            </span><span class="no">key: key-ref</span>
<span class="w">            </span><span class="no">operator: op</span>
<span class="w">            </span><span class="no">values:</span>
<span class="w">            </span><span class="no">- value1</span>
<span class="w">            </span><span class="no">...</span>
<span class="w">            </span><span class="no">- valueN</span>
<span class="w">          </span><span class="no">match:</span>
<span class="w">            </span><span class="no">key: key-ref</span>
<span class="w">            </span><span class="no">operator: op</span>
<span class="w">            </span><span class="no">values:</span>
<span class="w">            </span><span class="no">- value1</span>
<span class="w">            </span><span class="no">...</span>
<span class="w">            </span><span class="no">- valueN</span>
<span class="w">          </span><span class="no">weight: w</span>
</pre></div>
</div>
</section>
<section id="affinity-semantics">
<h3>Affinity Semantics<a class="headerlink" href="#affinity-semantics" title="Link to this heading"></a></h3>
<p>An affinity consists of three parts:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scope</span> <span class="pre">expression</span></code>: defines which containers this affinity is evaluated against</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">expression</span></code>: defines for which containers (within the scope) the
affinity applies to</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight</span></code>: defines how <em>strong</em> a pull or a push the affinity causes</p></li>
</ul>
<p><em>Affinities</em> are also sometimes referred to as <em>positive affinities</em> while
<em>anti-affinities</em> are referred to as <em>negative affinities</em>. The reason for this is
that the only difference between these are that affinities have a <em>positive weight</em>
while anti-affinities have a <em>negative weight</em>.</p>
<p>The <em>scope</em> of an affinity defines the <em>bounding set of containers</em> the
affinity can apply to. The affinity <em>expression</em> is evaluated against the
containers <em>in scope</em> and it <em>selects the containers</em> the affinity really has
an effect on. The <em>weight</em> specifies whether the effect is a <em>pull</em> or a
<em>push</em>. <em>Positive</em> weights cause a <em>pull</em> while <em>negative</em> weights cause a
<em>push</em>. Additionally, the <em>weight</em> specifies <em>how strong</em> the push or the pull
is. This is useful in situations where the policy needs to make some
compromises because an optimal placement is not possible. The weight then also
acts as a way to specify preferences of priorities between the various
compromises: the heavier the weight the stronger the pull or push and the
larger the probability that it will be honored, if this is possible at all.</p>
<p>The scope can be omitted from an affinity in which case it implies <em>Pod scope</em>,
in other words the scope of all containers that belong to the same Pod as the
container for which which the affinity is defined.</p>
<p>The weight can also be omitted in which case it defaults to -1 for
anti-affinities and +1 for affinities. Weights are currently limited to the
range [-1000,1000].</p>
<p>Both the affinity scope and the expression select containers, therefore they
are identical. Both of them are <em>expressions</em>. An expression consists of three
parts:</p>
<ul class="simple">
<li><p>key: specifies what <em>metadata</em> to pick from a container for evaluation</p></li>
<li><p>operation (op): specifies what <em>logical operation</em> the expression evaluates</p></li>
<li><p>values: a set of <em>strings</em> to evaluate the the value of the key against</p></li>
</ul>
<p>The supported keys are:</p>
<ul class="simple">
<li><p>for pods:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qosclass</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels/&lt;label-key&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uid</span></code></p></li>
</ul>
</li>
<li><p>for containers:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pod/&lt;pod-key&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qosclass</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels/&lt;label-key&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tags/&lt;tag-key&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code></p></li>
</ul>
</li>
</ul>
<p>Essentially an expression defines a logical operation of the form (key op values).
Evaluating this logical expression will take the value of the key in  which
either evaluates to true or false.
a boolean true/false result. Currently the following operations are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Equals</span></code>: equality, true if the <em>value of key</em> equals the single item in <em>values</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NotEqual</span></code>: inequality, true if the <em>value of key</em> is not equal to the single
item in <em>values</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">In</span></code>: membership, true if <em>value of key</em> equals to any among <em>values</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NotIn</span></code>: negated membership, true if the <em>value of key</em> is not equal to any
among <em>values</em></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Exists</span></code>: true if the given <em>key</em> exists with any value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NotExists</span></code>: true if the given <em>key</em> does not exist</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AlwaysTrue</span></code>: always evaluates to true, can be used to denote node-global
scope (all containers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Matches</span></code>: true if the <em>value of key</em> matches the globbing pattern in values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MatchesNot</span></code>: true if the <em>value of key</em> does not match the globbing pattern
in values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MatchesAny</span></code>: true if the <em>value of key</em> matches any of the globbing patterns
in values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MatchesNone</span></code>: true if the <em>value of key</em> does not match any of the globbing
patterns in values</p></li>
</ul>
<p>The effective affinity between containers C_1 and C_2, A(C_1, C_2) is the sum
of the weights of all pairwise in-scope matching affinities W(C_1, C_2). To put
it another way, evaluating an affinity for a container C_1 is done by first
using the scope (expression) to determine which containers are in the scope of
the affinity. Then, for each in-scope container C_2 for which the match
expression evaluates to true, taking the weight of the affinity and adding it
to the effective affinity A(C_1, C_2).</p>
<p>Note that currently (for the topology-aware policy) this evaluation is
asymmetric: A(C_1, C_2) and A(C_2, C_1) can and will be different unless the
affinity annotations are crafted to prevent this (by making them fully
symmetric). Moreover, A(C_1, C_2) is calculated and taken into consideration
during resource allocation for C_1, while A(C_2, C_1) is calculated and taken
into account during resource allocation for C_2. This might be changed in a
future version.</p>
<p>Currently affinity expressions lack support for boolean operators (and, or, not).
Sometimes this limitation can be overcome by using joint keys, especially with
matching operators. The joint key syntax allows joining the value of several keys
with a separator into a single value. A joint key can be specified in a simple or
full format:</p>
<ul class="simple">
<li><p>simple: <code class="docutils literal notranslate"><span class="pre">&lt;colon-separated-subkeys&gt;</span></code>, this is equivalent to
<code class="docutils literal notranslate"><span class="pre">:::&lt;colon-separated-subkeys&gt;</span></code></p></li>
<li><p>full:   <code class="docutils literal notranslate"><span class="pre">&lt;ksep&gt;&lt;vsep&gt;&lt;ksep-separated-keylist&gt;</span></code></p></li>
</ul>
<p>A joint key evaluates to the values of all the <code class="docutils literal notranslate"><span class="pre">&lt;ksep&gt;</span></code>-separated subkeys
joined by <code class="docutils literal notranslate"><span class="pre">&lt;vsep&gt;</span></code>. A non-existent subkey evaluates to the empty string. For
instance the joint key</p>
<p><code class="docutils literal notranslate"><span class="pre">:pod/qosclass:pod/name:name</span></code></p>
<p>evaluates to</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;qosclass&gt;:&lt;pod</span> <span class="pre">name&gt;:&lt;container</span> <span class="pre">name&gt;</span></code></p>
<p>For existence operators, a joint key is considered to exist if any of its
subkeys exists.</p>
</section>
<section id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h3>
<p>Put the container <code class="docutils literal notranslate"><span class="pre">peter</span></code> close to the container <code class="docutils literal notranslate"><span class="pre">sheep</span></code> but far away from the
container <code class="docutils literal notranslate"><span class="pre">wolf</span></code>.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="nt">resource-policy.nri.io/affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">peter:</span>
<span class="w">      </span><span class="no">- match:</span>
<span class="w">          </span><span class="no">key: name</span>
<span class="w">          </span><span class="no">operator: Equals</span>
<span class="w">          </span><span class="no">values:</span>
<span class="w">          </span><span class="no">- sheep</span>
<span class="w">        </span><span class="no">weight: 5</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/anti-affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">peter:</span>
<span class="w">      </span><span class="no">- match:</span>
<span class="w">          </span><span class="no">key: name</span>
<span class="w">          </span><span class="no">operator: Equals</span>
<span class="w">          </span><span class="no">values:</span>
<span class="w">          </span><span class="no">- wolf</span>
<span class="w">        </span><span class="no">weight: 5</span>
</pre></div>
</div>
</section>
<section id="shorthand-notation">
<h3>Shorthand Notation<a class="headerlink" href="#shorthand-notation" title="Link to this heading"></a></h3>
<p>There is an alternative shorthand syntax for what is considered to be the most common
case: defining affinities between containers within the same pod. With this notation
one needs to give just the names of the containers, like in the example below.</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">container3: [ container1 ]</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/anti-affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">      </span><span class="no">container3: [ container2 ]</span>
<span class="w">      </span><span class="no">container4: [ container2, container3 ]</span>
</pre></div>
</div>
<p>This shorthand notation defines:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">container3</span></code> having</p>
<ul>
<li><p>affinity (weight 1) to <code class="docutils literal notranslate"><span class="pre">container1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anti-affinity</span></code> (weight -1) to <code class="docutils literal notranslate"><span class="pre">container2</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">container4</span></code> having</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">anti-affinity</span></code> (weight -1) to <code class="docutils literal notranslate"><span class="pre">container2</span></code>, and <code class="docutils literal notranslate"><span class="pre">container3</span></code></p></li>
</ul>
</li>
</ul>
<p>The equivalent annotation in full syntax would be</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|+</span>
<span class="w">      </span><span class="no">container3:</span>
<span class="w">      </span><span class="no">- match:</span>
<span class="w">          </span><span class="no">key: labels/io.kubernetes.container.name</span>
<span class="w">          </span><span class="no">operator: In</span>
<span class="w">          </span><span class="no">values:</span>
<span class="w">          </span><span class="no">- container1</span>
<span class="w">    </span><span class="nt">resource-policy.nri.io/anti-affinity</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|+</span>
<span class="w">      </span><span class="no">container3:</span>
<span class="w">      </span><span class="no">- match:</span>
<span class="w">          </span><span class="no">key: labels/io.kubernetes.container.name</span>
<span class="w">          </span><span class="no">operator: In</span>
<span class="w">          </span><span class="no">values:</span>
<span class="w">          </span><span class="no">- container2</span>
<span class="w">      </span><span class="no">container4:</span>
<span class="w">      </span><span class="no">- match:</span>
<span class="w">          </span><span class="no">key: labels/io.kubernetes.container.name</span>
<span class="w">          </span><span class="no">operator: In</span>
<span class="w">          </span><span class="no">values:</span>
<span class="w">          </span><span class="no">- container2</span>
<span class="w">          </span><span class="no">- container3</span>
</pre></div>
</div>
<!-- Links -->
</section>
</section>
<section id="metrics-and-debugging">
<h2>Metrics and Debugging<a class="headerlink" href="#metrics-and-debugging" title="Link to this heading"></a></h2>
<p>In order to enable more verbose logging and metrics exporting from the
topology-aware policy, enable instrumentation and policy debugging from
the nri-resource-policy global config:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">instrumentation</span><span class="p">:</span>
<span class="w">  </span><span class="c1"># The topology-aware policy can exports various system and topology</span>
<span class="w">  </span><span class="c1"># zone utilisation metrics. Accessible in command line with</span>
<span class="w">  </span><span class="c1"># curl --silent http://$localhost_or_pod_IP:8891/metrics</span>
<span class="w">  </span><span class="nt">HTTPEndpoint</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">:8891</span>
<span class="w">  </span><span class="nt">PrometheusExport</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">  </span><span class="nt">metrics</span><span class="p">:</span>
<span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="c1"># use &#39;*&#39; instead for all available metrics</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">policy</span>
<span class="nt">logger</span><span class="p">:</span>
<span class="w">  </span><span class="nt">Debug</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">policy</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Policies" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="balloons.html" class="btn btn-neutral float-right" title="Balloons Policy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, various.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
  
    <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
      <span class="rst-current-version" data-toggle="rst-current-version">
        <span class="fa fa-book"> GitHub Pages</span>
        v0.9
        <span class="fa fa-caret-down"></span>
      </span>
      <div class="rst-other-versions">
        <dl id="versions">
          <dt>Versions</dt>
        </dl>
        <dl>
          <dt>
          <a href="/nri-plugins/releases">all releases</a>
          </dt>
        </dl>
      </div>
    </div>
  
  <script src="../../../../versions.js"></script>
  <script>
      var list = document.getElementById('versions')
      var menuItems = getVersionsMenuItems();
      for (var i=0; i < menuItems.length; i++) {
        var item = document.createElement('dd');
        var anchor = item.appendChild(document.createElement('a'));
        anchor.appendChild(document.createTextNode(menuItems[i].name));
        anchor.href = menuItems[i].url;
        list.appendChild(item);
      }
  </script>


</body>
</html>